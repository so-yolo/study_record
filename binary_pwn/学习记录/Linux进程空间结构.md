#### 空间结构的讲解：

- 在Linux进程创建的过程中，一个进程的创建会分别在内核空间和用户空间的虚拟地址创建相应的数据。

- Linux的虚拟地址空间范围为0～4G，Linux内核将这4G字节的空间分为两部分， 将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为“内核空间”。而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供各个进程使用，称为“用户空间。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。 （ 这里是32位内核地址空间划分，64位内核地址空间划分是不同的 ）

下面是 Linux 进程空间结构的主要组成部分：

1. 代码段（Text Segment）：

- 代码段存储了进程的可执行代码，包括程序的指令集和常量数据。这部分数据通常是只读的，用于存放程序的机器指令，例如执行程序的函数、方法和算法等。

2. 数据段（Data Segment）：

- 数据段包含了已初始化的全局变量、静态变量以及常量数据。这些数据通常是可读写的，用于存放进程运行时需要使用的各种数据。

3. BSS 段：

- BSS 段（Block Started by Symbol）包含了未初始化的全局变量和静态变量。这些变量在程序运行时会被系统初始化为零或空值。BSS 段也是可读写的。

4. 堆（Heap）：

- 堆是动态分配的内存区域，用于存储动态生成的数据结构或者变长数据。在 C 语言中，通过 malloc()、calloc()、realloc() 等函数来分配堆内存，在不需要时需要手动释放。

5. 栈（Stack）：

- 栈用于存储函数的局部变量、函数参数、返回地址以及函数调用过程中的临时数据。每个线程都有自己的栈空间，栈采用先进后出（FILO）的方式管理数据。

6. 内存映射区域（Memory Mapped Regions）：

- 进程的虚拟地址空间还包括了一些内存映射区域，用于将文件映射到内存，实现对文件内容的直接访问和处理。

7. 页表和虚拟内存管理：

Linux 使用页表和虚拟内存管理机制来实现进程的虚拟地址空间和物理内存的映射关系。页表记录了虚拟页面和物理页面之间的映射关系，实现了虚拟内存管理和分页机制。

8. 内核空间：而内核空间包含了操作系统内核运行的地方，用户程序无法直接访问内核空间的地址。

用户空间是进程可以直接访问的地址空间范围，包括代码段，数据段，bss段，堆，栈，内存映射区域。

下图是32位和64位进程虚拟地址空间的结构。

对于下面的图1.2.3，有的是Memmory Mapping Region（内存映射区域），有的是共享区，为此我查了一下，共享区域指的是在进程间共享数据的内存区域，通常包括共享内存（Shared Memory）、内存映射文件（Memory-mapped Files）等。因此共享区包括Memmory Mapping Region，而Memmory Mapping Region 包括共享内存和内存映射文件。

且要提的一点是：堆的地址增长是由低到高，而栈的地址是由高到低。

![[Pasted image 20240923214823.png]]

![[Pasted image 20240923214834.png]]

![[Pasted image 20240923214841.png]]

关于为什么64位地址空间为什么比32地址空间多个empty space这里我查了资料，主要是由于它们的地址位数不同，以及地址转换和对齐规则的不同导致的。详细原因如下：

1. 地址位数不同：

- 32位地址空间中，每个地址有32个比特（bit），可以表示的地址数量有限，即$2^{32}$个地址。
- 而64位地址空间中，每个地址有64个比特（bit），可以表示的地址数量远远超过32位地址空间，即$2^{64}$个地址。这意味着64位地址空间的地址范围更大，能够表示的地址更多。

2. 地址转换和对齐规则不同：

- 在地址转换和内存对齐方面，32位和64位系统有不同的规则。例如，在32位系统中，通常使用的地址转换机制是段式存储模型，地址空间被划分为不同的段，并且存在段间的空洞，这会导致32位地址空间中出现一些空白区域。
- 相比之下，64位系统通常采用页式存储模型，地址空间被划分为固定大小的页面，地址转换是通过页表来实现的。64位系统的地址转换更加灵活和高效，不会出现类似于段式存储模型中的空洞，因此空白空间相对较少。

!![[Pasted image 20240923214853.png]]

![[Pasted image 20240923214906.png]]