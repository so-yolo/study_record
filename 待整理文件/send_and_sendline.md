# pwntools 中 send 和 sendline 的使用场景及判断依据

在 pwntools 中，`send` 和 `sendline` 的核心区别在于：`sendline`**&#x20;会在发送的数据末尾自动添加一个换行符（**`\n`**），而&#x20;**`send`**&#x20;仅发送原始数据**。选择使用哪个函数，取决于**程序对输入的处理方式**（即程序期望如何判断输入结束）。

### 1. 用 `send` 的情况：程序不需要换行符作为输入结束标志

当程序通过 `read`、`recv` 等函数读取固定长度的输入（不依赖换行符判断结束）时，必须用 `send`，避免额外的换行符破坏 payload 的精确性。

典型场景：



* **缓冲区溢出漏洞**：需要严格控制发送的字节数（例如覆盖返回地址的偏移必须精确）。如果用 `sendline`，额外的 `\n` 会多占 1 字节，可能导致偏移计算错误。



```
\# 例：程序用 read(0, buf, 0x20) 读取 0x20 字节

payload = b'A'\*0x20 + p32(0xdeadbeef)  # 精确构造 0x24 字节

p.send(payload)  # 正确：发送 payload 本身，无额外字符
```



* **二进制协议交互**：程序按固定格式解析输入（如前 4 字节为长度，后 n 字节为内容），不需要换行符。



```
\# 例：协议格式为 \[4字节长度]\[n字节数据]

data = b'payload'

payload = p32(len(data)) + data

p.send(payload)  # 发送精确的长度+数据，无多余字符
```

### 2. 用 `sendline` 的情况：程序需要换行符作为输入结束标志

当程序通过 `gets`、`fgets`、`scanf("%s")` 等函数读取输入（以换行符 `\n` 作为结束标志）时，必须用 `sendline`，否则程序会一直等待输入（因为未收到结束标志）。

典型场景：



* **命令行式输入**：程序像终端一样，等待用户输入一行文本（以回车 / 换行结束）。



```
// 程序侧代码示例（C语言）

char buf\[100];

gets(buf);  // gets 以换行符判断输入结束，并会自动去掉换行符
```

对应的 exploit 代码需要用 `sendline`：



```
payload = b'A'\*100 + p32(0xdeadbeef)

p.sendline(payload)  # 自动添加 \n，让 gets 认为输入结束
```



* **交互型程序**：需要模拟用户 “输入后按回车” 的操作（如登录框输入用户名 / 密码）。



```
\# 例：程序提示 "Username: "，等待输入后按回车

p.sendline(b'admin')  # 等价于发送 b'admin\n'，符合用户操作习惯
```

### 总结：核心判断依据



* 看程序如何读取输入：


  * 若用 `read(fd, buf, n)`（固定长度）→ 用 `send`（避免多发送 `\n`）。

  * 若用 `gets`、`fgets`、`scanf("%s")`（依赖换行符结束）→ 用 `sendline`（必须加 `\n`）。

* 调试时可通过 `p.interactive()` 手动输入测试：如果手动输入后需要按回车程序才继续，就用 `sendline`；否则用 `send`。

> （注：文档部分内容可能由 AI 生成）