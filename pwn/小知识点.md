### 堆溢出
堆溢出经常出现在edit函数里面或者申请堆块里面(后者情况较少)

输入的大小如果大于堆块的大小，那就可以使用堆溢出(利用堆块重叠)，可以达到修改下一个堆块的fd指针进一步为我们使用

### 获取libc基址
把堆块释放之后，malloc再申请回来没有把指针清零，所以堆块的fd,bk指针里面都有libc地址残留，通过打印函数打印堆块就能获得libc地址,从而获取libc基址

### 堆块合并
unsortedbin如果和top chunk挨着的话，unsortedbin会和top chunk合并，所以要在申请的堆块最后多添一个占位的堆块隔离防止有用堆块被合并

### ubuntu版本对应堆块管理器的使用
2.23-2.26 (fastbin)

2.26-目前（tcache bin）

### 无符号转有符号漏洞
![[Pasted image 20241102154911.png]]
可以发现发现nbytes为size_t类型，该类型是标准C库中定义的，为unsigned int类型，即无符号整数类型，但在if判断时将其转为有符号整型，而read时又为无符号整型，那就存在无符号转有符号漏洞。

假设当我们输入一个无符号整数ffff，即65535，但ff转为有符号时，则将表示为-1，-1<10，这时对
read函数来说读取的字节大小就是65535字节。

### /bin/sh打不通
![[Pasted image 20241102155001.png]]



### gets函数
gets函数只有接收到回车才会进行下一步

### puts函数
puts函数是一个高级函数，也就是执行这个函数过程中会调用一些其他函数，例如strlen()函数，

![[Pasted image 20241102155147.png]]

如图为puts函数汇编代码开头一部分，可以看到在执行strlen函数之前rdi寄存器是没有被改变的，一直是puts()函数接收的数据那么我们就可以利用修改strlen函数的got表，使之找到system，那么我们在使用puts函数的时候只需要把原始数据'/bin/sh'发送过去，就能够执行system /bin/sh获取权限

puts函数打印一行数据，也就是默认加了\\n

\\n也是一个字符
\\x00是空字符的意思

### libc对应的ubuntu版本
1.libc2.23    16.04
2.libc2.27    18.04
3.libc2.31    20.04
4.libc2.35    22.04

%hn和%hhn
![[Pasted image 20241102155336.png]]

python好用的函数
.swapcase()         让字符串大写转为小写，小写转为大写
.lower()                 让字符串大写转小写
.replace(' ','')         把空格去掉