    afl根据不同情况有不同的插桩方法：
1. 静态插桩：在编译时对代码进行插桩，主要是在代码中插入一些指令，用于记录代码的执行路径，从而实现覆盖率的统计。
2. 动态插桩：在运行时对代码进行插桩，主要是在代码中插入一些指令，用于记录代码的执行路径，从而实现覆盖率的统计。
3. 混合插桩：结合静态插桩和动态插桩，主要是在编译时对代码进行插桩，同时在运行时对代码进行插桩，从而实现覆盖率的统计。
-------------------------------------------------------------------------
    
    关于用到的两大编译器项目:
1.GCC（GNU Compiler Collection）原生编译器是afl-gcc和afl-g++的底层依赖。当使用afl-gcc编译 C 代码或afl-g++编译 C++ 代码时，这些 AFL 工具本质上会调用系统中安装的原生gcc或g++，并在编译流程中插入 AFL 的插桩逻辑。原生 GCC 负责代码的语法分析、优化、生成汇编代码等核心编译工作，AFL 仅在其基础上增加路径追踪相关的插桩代码。

2.Clang/LLVM原生的 Clang 编译器（基于 LLVM 架构）是afl-clang、afl-clang++和afl-clang-fast的底层依赖。
afl-clang/afl-clang++直接包装原生clang/clang++，在编译过程中插入插桩代码；
afl-clang-fast则利用 LLVM 的中间表示（IR）机制，直接在 LLVM IR 层面进行插桩，依赖原生 LLVM 工具链（如llc、opt等）完成后续编译步骤。
原生 Clang/LLVM 提供了高效的代码生成和优化能力，是 AFL 支持高级特性（如快速插桩、强化模式）的基础。

-------------------------------------------------------------------------

基于 GCC/Clang 传统编译流程的工具（汇编阶段插桩）
afl-gcc、afl-g++：对 GCC 编译器的包装，在源代码编译生成汇编代码后，直接修改汇编代码，插入路径追踪指令（如基本块计数逻辑），属于汇编阶段插桩。
afl-clang、afl-clang++：对 Clang 编译器的包装，与 afl-gcc 逻辑类似，在编译器生成汇编代码后修改汇编指令，同样属于汇编阶段插桩。
这类工具的插桩方式相对传统，依赖编译器生成汇编代码后进行二次修改，效率中等。
基于 LLVM IR 的工具（中间代码阶段插桩）
afl-clang-fast、afl-clang-fast++：直接操作 LLVM 中间表示（IR），在源代码被编译为 IR 后（早于汇编阶段），通过 LLVM 插件在 IR 层面插入插桩逻辑，再由 LLVM 后端将修改后的 IR 转换为汇编和机器码，属于LLVM IR 阶段插桩。
这种方式跳过了汇编代码生成后的修改步骤，直接在中间代码层操作，插桩效率更高，且支持更多高级特性（如 AFL_HARDEN 模式）。
动态二进制插桩工具（运行时插桩）
afl-qemu-trace：基于 QEMU 模拟器，无需源代码，在二进制程序运行时通过动态指令翻译插入路径追踪逻辑，属于动态二进制插桩。
适用于无法重新编译的闭源二进制程序，插桩阶段在程序执行过程中，效率相对较低，但兼容性最广。

afl-gcc,afl-g++ 是在汇编代码阶段插桩
afl-clang,afl-clang++ 是在汇编代码阶段插桩
afl-clang-fast,afl-clang-fast++ 是在LLVM IR 插入桩
afl-qemu-trace 是在LLVM IR 插入桩

-------------------------------------------------------------------------

编译器与汇编器：
高级语言 → 编译器 → 汇编语言或机器码
汇编语言 → 汇编器 → 机器码